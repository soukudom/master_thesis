
\section{Integrace kolektoru}    
     % popsat trochu jak probihala integrace kolektoru
     Vytvořený kolektor provozních dat je přímou součástí projektu BeeeOn, a proto jej bylo nutné 
     integrovat do spouštěcího procesu brány. Pro zajištění společné kompilace byly do souborů 
     \textit{CMakeLists.txt} přidány cesty ke zdrojovým souborům kolektoru a závislosti na knihovny
     z NEMEA frameworku. K určení způsobu spouštění jednotlivých komponent používá BeeeOn
     soubor \textit{factory.xml}. V tomto souboru byla vytvořena nová komponenta s názvem 
     \textit{collector}, 
     která byla následně přidána pod označením \textit{listener} do ostatních komponent. Toto nastavení 
     umožňuje přijímání definovaných událostí v rámci návrhového vzoru \textit{Observer}.
     Samotná komponenta
     obsahuje ve svém popisu seznam jmen událostí, kterým přiřazuje pojmenování výstupního \textit{libtrap}
     rozhraní. Formát výstupu je vždy \textit{event-<názevUdálosti>}. 
     
     Vytvořené názvy událostí jsou při spouštění programu pomocí C++ reflexe předány třídě kolektoru
     \textit{NemeaCollector}. Tato třída používá již vytvořené makro \textit{BEEEON\_OBJECT\_TEXT},
     které pro definovaný seznam 
     událostí volá příslušné členské funkce. Každá událost má členskou funkci s názvem ve formátu 
     \textit{set<názevUdálosti>} přijímající jeden vstupní parametr typu string s názvem výstupního 
     rozhraní. V rámci volání se do instance třídy \textit{EventMetaData}
     nastaví specifické hodnoty členských
     atributů dané události. Následuje volání členské funkce \textit{initInterface(EventMetaData)},
     která přijímá vytvořenou instanci třídy  \textit{EventMetaData} a
     jednotně inicializuje všechny potřebné struktury pro odesílání dat.
     
     Po úspěšném nastavení všech částí se už jen v rámci návrhového vzoru \textit{Observer} volají
     členské funkce událostí, které jsou definované ve třídě \textit{AbstractCollector} a implementované
     ve třídě \textit{NemeaCollector}. Získané informace jsou vkládány do UniRec zprávy a odeslány
     výstupním rozhraním.
     
\section{Mux a Demux}    

 Modul \textit{Mux} očekává na vstupu přepínač \textit{-i}, který ve formě řetězce určuje dostupná 
 rozhraní 
 zajištěné knihovnou \textit{libtrap}. Poslední identifikátor v řetězci označuje jméno 
 výstupu. Druhým parametrem je \textit{-n}, který odpovídá počtu vstupních rozhraní. Při spuštění 
 se pro každý vstup pomocí knihovny OpenMP vytvoří samostatné vlákno. Jelikož je veškerý provoz 
 odesílaný jedním společným rozhraním, bylo nutné funkci \textit{trap\_ctx\_send} vložit do
 kritické sekce, 
 protože pracuje se sdílenými strukturami pro všechny vlákna.
 
 Společné spojení mezi moduly vytvořenými \textit{Mux} a \textit{Demux} používá nastavený typ
 \textit{TRAP\_FMT\_RAW},
 který umožňuje posílat zprávy ve vlastně definovaném formátu. Hlavička vytvořeného formátu
 obsahuje: identifikátor druhu zprávy, číslo rozhraní a typ formátu. Obsah přijatých zpráv
 je zapouzdřen do záhlaví. \textit{Mux} při každém přijetí dat kontroluje návratový
 kód funkce \textit{trap\_ctx\_recv}, který identifikuje nový formát přijatých zpráv. Pokud
 dojde k detekování změny, tak se pošle \textit{hello} zpráva s upraveným popisem rozhraní.
 V ostatních případech se jen přeposílají zapouzdřená data.
 
 Modul \textit{Demux} vyžaduje stejné přepínače jako \textit{Mux}. Jediným rozdílem je, že 
 název společného rozhraní, které má \textit{Mux} na posledním místě, musí být zde uveden 
 jako první. Důvodem je, že knihovna \textit{libtrap} zpracovává nejprve vstupní a pak
 výstupní rozhraní. 
 
\section{Zpracování zadaných parametrů}

Načtení konfiguračního souboru má na starosi třída \textit{ConfigParser}, která neprovádí 
žádnou kontrolu vstupních dat, protože se již od návrhu předpokládá, že konfigurace bude 
generována odlišným programem, který zajistí správnost parametrů. Jediný konstruktor třídy
 \textit{ConfigParser} očekává jako parametr řetězec s cestu k cílovému souboru. Během vytváření
 objektu jsou postupně zpracovány jednotlivé řádky zadaného souboru. Zároveň budou incializovány
 pole pro uchovávání vypočtených profilů. Jejich délka je specifikována preprocesorovou direktivou
 \textit{\#define DYNAMIC}.
 
Pokud byly zadány parametry pro pravidelný export dat, tak se při inicializaci potřebných struktur
zavolá funkce s názvem \textit{initExportInterfaces}, která vytvoří příslušná výstupní 
rozhraní. Jejich název je vždy vygenerován v následujícím formátu: 
\textit{u:export-<názevKlíče><idKlíče>}.
   
\section{Výpočet profilu}   
Veškeré přijaté údaje z kolektoru jsou v rámci detektoru ukládány do časových řad. Nad těmito 
daty jsou prováděny výpočty profilů, které využívají detekční funkce. Jelikož jsou profily
přepočítávány s každým nový prvkem v časové řadě, tak je důležité provádět výpočty efektivně, 
aby nemusela být vždy procházena celá řady při změně jednohé hodnoty. Během implementace byly
vytvořeny členské funkce pro výpočet následujících částí profilu: průměr, klouzavý průměr, rozptyl a
medián. Tyto členské funkce jsou popsány v níže uvedených sekcích.

\begin{itemize}
 \item \textbf{getMedian(\textit{sensor\_it, meta\_it, ur\_field, ur\_id})}
 
 Pro výpočet mediánu je potřeba udržovat položky aktálního časového okna v seřazeném pořadí.
 Při vkládání nového prvku je potřeba najít nejstarší prvek v poli a nahradit ho nově přijatým. 
 Po provedeném nahrazení se pole udržující jednotlivé hodnoty nachází v neseřazeném stavu a je nutné
 ho znovu seřadit. Tato operace není náročná, protože se změní vždy jen jeden prvek, který je nutný
 přesunou na správné místo. Celková složitost začlenění nového prvku je $O(n)$, protože operace 
 nalezení a seřazení lze provést v lineárním čase. Paměťové nároky vyžadují alokování dodatečného
 místa, které bude obsahovat kopii časové řady.
 
 Dále je potřeba zjisit, zda je časová řada sudé nebo liché délky. Pokud je lichá, tak se jako 
 medián vrátí její prvek umístění ve středu. V opačném případě je výsledkem průměr dvou prostředních
 hodnot.
 
 Aby mohly být provedy veškeré popsané operace, tak členská funkce pro výpočet mediánu
 potřebuje tyto parametry:
 \begin{itemize}
   \item \textbf{sensor\_it}: iterátor na časovou řadu daného UniRec pole
   \item \textbf{meta\_it}: iterátor na meta informace o daném UniRec poli
   \item \textbf{ur\_field}: název zpracovávaného UniRec pole
   \item \textbf{ur\_id}: identifikátor přijatého UniRec pole
 \end{itemize}
 
 \item \textbf{getAverageAndVariance(\textit{ur\_field, ur\_id, meta\_it, sensor\_it, meta\_id})}
 
 Tato členská funkce je zaměřená zejména na získání rozptylu, ale v rámci jeho výpočtu je možné
 získat i hodnotu průměru, a proto jsou v návratové hodnotě vraceny oba výsledky. Průběh
 zpracování údajů probíhá s ohledem na vstupní data, která 
 jsou reprezentována stále se posouvajícím časovým oknem. 
 
 Pro umožnějí efektivního výpočtu se používá několik pomocným paměťových struktur. První z nich 
 jsou dvě pole \textit{x} a \textit{x2} se shodnou velikostí jako má hlavní časová řada. Do pole
 \textit{x} jsou ukládána
 nově příchozí data a \textit{x2} udržuje jejich druhé mocniny. Dále je nutné ukládat součty
 hodnot v těchto polích, které jsou uchovávány v proměných \textit{SX} a \textit{SX2}.
 
 V rámci učící fáze detektoru jsou i zde příchozí prvky postupně vkládány do připravených struktur.
 Pokud jsou již pomocná pole naplněná, tak při příchodu nové položky se používá funkce
 \textit{rotate()}, která provede levou rotaci prvků a umístí nejstarší prvek na konec. Tento
 prvek je poté nahrazen nejnovější hodnotou. Součty jednotlivých polí jsou upraveny podle 
 následujícího předpisu:  
 \[
  součetŘady + novýPrvek - nejstaršíPrvek
\]
 
 Po upravení pomocných struktu je možné provést finální výpočet. Průměr je snadno získán vydělením
 udržované součtu počtem prvků v časové řadě (\textit{N}). Pro určení hodnoty rozptylu se provádí
 následující operace:
\[
   \frac{N * SX2 - SX * SX}{N * (N - 1)}
\]
Pro získání veškerých hodnot pro popsané výpočty přijímá členská funkce stejné vstupní parametry
jako \textit{getMedian()} a navíc je ještě očekávána hodnota \textit{meta\_id}, která určuje, 
zda bude v rámci metadat použita skupina \textit{metaData} nebo \textit{metaProfile} \ref{configParam}. 

 \item \textbf{getCumulativeAverage(\textit{sensor\_it, meta\_it, meta\_id, ur\_id})}
 
 Poslední možnou částí vypočítavaného profilu sítě je klouzavý průměr, který je získán v rámci 
 této členské funkce. Na rozdíl od ostatních metod jsou v tomto případě zahrnuty i položky 
 mimo časové okno. Hodnota klouzavého průměru reprezentuje průměr všech dosud přijatých dat pro 
 daný UniRec klíč. Výpočetní operace využívá znalosti aktuálního průměru, které při přijetí 
 nové položky upravuje dle následujícího předpisu:
 \[
   \frac{novýPrvek + (N - 1) * aktuálníPrůměr}{N}
\]
 
\end{itemize}


   %popis vypoctu profilu
\section{Detekční funkce} 
 % algoritmus detektoru popsat jednotlivé detekční metody
  % popsat, ze periodicky veci jsou delany pomoci vlaken per polozku
    % hlavní je že je to proto, že se nedozvi info o čase když nepřijdou data, tak to musim dělat sám